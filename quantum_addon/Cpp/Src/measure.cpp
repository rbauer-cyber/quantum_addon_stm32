//$file${.::measure.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: addon.qm
// File:  ${.::measure.cpp}
//
// This code has been generated by QM 7.0.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::measure.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "measure.hpp"
#include "console.h"
#include "main.h"

// ask QM to declare the Measure class
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${BaseAOs::CMeasure} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace APP {

//${BaseAOs::CMeasure} .......................................................

//${BaseAOs::CMeasure::UpdateElapsedTime} ....................................
void CMeasure::UpdateElapsedTime() {
    if ( m_running )
    {
        m_intervalEndTime = getMicros();
        uint32_t elapsedTime = m_intervalEndTime - m_intervalStartTime;
        uint32_t elapsedTimeDelta = 0;

        if ( elapsedTime >= kMinElapsedTime )
        {
            if ( m_updateCount >= kIntervalOffset )
            {
                if ( elapsedTime > m_intervalElapsedTime )
                    elapsedTimeDelta = elapsedTime - m_intervalElapsedTime;
                else
                    elapsedTimeDelta = m_intervalElapsedTime - elapsedTime;

                m_intervalCount += 1;

                if ( elapsedTimeDelta > m_maxElapsedTimeDelta )
                {
                    m_maxElapsedTimeDelta = elapsedTimeDelta;
                }
                if ( elapsedTimeDelta < m_minElapsedTimeDelta )
                {
                    m_minElapsedTimeDelta = elapsedTimeDelta;
                }

                m_avgElapsedTimeDelta += elapsedTimeDelta;
                m_avgElapsedTime += elapsedTime;

                if ( elapsedTimeDelta > 100 )
                {
                    m_intervalThresholdCount += 1;
                }
            }
            else
            {
                m_updateCount += 1;
            }

            m_intervalElapsedTime = elapsedTime;
        }
    }
}

//${BaseAOs::CMeasure::DisplayElapsedTime} ...................................
void CMeasure::DisplayElapsedTime() {
    if ( m_running )
    {
        CONSOLE_DISPLAY_ARGS("elapsed time us = %d\r\n", m_intervalElapsedTime);
    }
}

//${BaseAOs::CMeasure::DisplayElapsedTimeDelta} ..............................
void CMeasure::DisplayElapsedTimeDelta() {
    if ( m_running )
    {
        if ( m_intervalCount >= kIntervalCount )
        {
            m_avgElapsedTimeDelta = m_avgElapsedTimeDelta / m_intervalCount;
            m_avgElapsedTime = m_avgElapsedTime / m_intervalCount;

            CONSOLE_DISPLAY_ARGS(
                "max/min/avg/avg/cnt elapsed time delta us = %d/%d/%d/%d/%d\r\n",
                m_maxElapsedTimeDelta, m_minElapsedTimeDelta,
                m_avgElapsedTimeDelta, m_avgElapsedTime,
                m_intervalThresholdCount);

            Reset();
        }
    }
}

//${BaseAOs::CMeasure::Initialize} ...........................................
void CMeasure::Initialize(
    std::uint32_t minElapsedTime,
    std::uint32_t intervalOffset,
    std::uint32_t intervalCount)
{
    kIntervalOffset = intervalOffset;
    kMinElapsedTime = minElapsedTime;
    kIntervalCount = intervalCount;

    Reset();
    m_running = false;
}

//${BaseAOs::CMeasure::Start} ................................................
void CMeasure::Start() {
    m_intervalStartTime = getMicros();
}

//${BaseAOs::CMeasure::CMeasure} .............................................
CMeasure::CMeasure()
: kIntervalOffset(4)
{}

//${BaseAOs::CMeasure::Run} ..................................................
void CMeasure::Run() {
    m_running = true;
}

//${BaseAOs::CMeasure::Stop} .................................................
void CMeasure::Stop() {
    m_running = false;
}

//${BaseAOs::CMeasure::Reset} ................................................
void CMeasure::Reset() {
    m_intervalElapsedTime = 0;
    m_maxElapsedTimeDelta = 0;
    m_minElapsedTimeDelta = 100;
    m_avgElapsedTimeDelta = 0;
    m_avgElapsedTime = 0;
    m_intervalCount = 0;
    m_intervalThresholdCount = 0;
    m_updateCount = 0;
}

} // namespace APP
//$enddef${BaseAOs::CMeasure} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
