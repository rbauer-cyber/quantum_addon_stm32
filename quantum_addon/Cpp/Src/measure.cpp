//$file${.::measure.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: addon.qm
// File:  ${.::measure.cpp}
//
// This code has been generated by QM 7.0.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::measure.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "measure.hpp"
#include "console.h"
#include "main.h"

// ask QM to declare the Measure class
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${BaseAOs::CMeasure} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace APP {

//${BaseAOs::CMeasure} .......................................................

//${BaseAOs::CMeasure::UpdateElapsedTime} ....................................
void CMeasure::UpdateElapsedTime() {
    m_intervalEndTime = getMicros();
    uint32_t elapsedTime = m_intervalEndTime - m_intervalStartTime;
    uint32_t elapsedTimeDelta = 0;

    if ( elapsedTime > 1000 )
    {
        if ( m_updateCount > kIntervalOffset )
        {
            if ( elapsedTime > m_intervalElapsedTime )
                elapsedTimeDelta = elapsedTime - m_intervalElapsedTime;
            else
                elapsedTimeDelta = m_intervalElapsedTime - elapsedTime;

            m_intervalCount += 1;

            if ( elapsedTimeDelta > m_maxElapsedTimeDelta )
            {
                m_maxElapsedTimeDelta = elapsedTimeDelta;
            }
            if ( elapsedTimeDelta < m_minElapsedTimeDelta )
            {
                m_minElapsedTimeDelta = elapsedTimeDelta;
            }

            m_avgElapsedTimeDelta += elapsedTimeDelta;
            m_avgElapsedTime += elapsedTime;

            if ( elapsedTimeDelta > 100 )
            {
                m_intervalThresholdCount += 1;
            }
        }
        else
        {
            m_updateCount += 1;
        }

        m_intervalElapsedTime = elapsedTime;
    }
}

//${BaseAOs::CMeasure::DisplayElapsedTime} ...................................
void CMeasure::DisplayElapsedTime() {
    CONSOLE_DISPLAY_ARGS("elapsed time us = %d\r\n", m_intervalElapsedTime);
}

//${BaseAOs::CMeasure::DisplayElapsedTimeDelta} ..............................
void CMeasure::DisplayElapsedTimeDelta() {
    if ( m_intervalCount > 120 )
    {
        m_avgElapsedTimeDelta = m_avgElapsedTimeDelta / m_intervalCount;
        m_avgElapsedTime = m_avgElapsedTime / m_intervalCount;

        CONSOLE_DISPLAY_ARGS(
            "max/min/avg/avg/cnt elapsed time delta us = %d/%d/%d/%d/%d\r\n",
            m_maxElapsedTimeDelta, m_minElapsedTimeDelta,
            m_avgElapsedTimeDelta, m_avgElapsedTime,
            m_intervalThresholdCount);

        m_maxElapsedTimeDelta = 0;
        m_minElapsedTimeDelta = 10000;
        m_avgElapsedTimeDelta = 0;
        m_avgElapsedTime = 0;
        m_intervalEndTime = getMicros();
        m_intervalThresholdCount = 0;
        m_intervalCount = 0;
    }
}

//${BaseAOs::CMeasure::Initialize} ...........................................
void CMeasure::Initialize() {
    m_intervalElapsedTime = 0;
    m_maxElapsedTimeDelta = 0;
    m_minElapsedTimeDelta = 10000;
    m_avgElapsedTimeDelta = 0;
    m_avgElapsedTime = 0;
    m_intervalCount = 0;
    m_intervalThresholdCount = 0;
    m_updateCount = 0;
}

//${BaseAOs::CMeasure::Start} ................................................
void CMeasure::Start() {
    m_intervalStartTime = getMicros();
}

//${BaseAOs::CMeasure::CMeasure} .............................................
CMeasure::CMeasure()
: kIntervalOffset(4)
{}

} // namespace APP
//$enddef${BaseAOs::CMeasure} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
