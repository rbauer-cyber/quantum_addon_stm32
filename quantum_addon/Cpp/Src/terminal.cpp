//$file${.::terminal.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: addon.qm
// File:  ${.::terminal.cpp}
//
// This code has been generated by QM 7.0.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::terminal.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp"             // QP/C++ real-time embedded framework
#include "terminal.hpp"               // DPP Application interface
#include <cstring>
#include "console.h"

//----------------------------------------------------------------------------
// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_FILE

}

//----------------------------------------------------------------------------
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${BaseShared::AO_Terminal} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace APP {

//${BaseShared::AO_Terminal} .................................................
QP::QActive * const AO_Terminal = &Terminal::inst;

} // namespace APP
//$enddef${BaseShared::AO_Terminal} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${BaseAOs::Terminal} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace APP {

//${BaseAOs::Terminal} .......................................................
Terminal Terminal::inst;

//${BaseAOs::Terminal::Terminal} .............................................
Terminal::Terminal()
  : QActive(Q_STATE_CAST(&initial)),
    m_timeEvt(this, TIMEOUT_SIG, 0U)
{}

//${BaseAOs::Terminal::DispatchCommand} ......................................
void Terminal::DispatchCommand(char command) {
    consoleDisplay("Empty Dispatch command\r\n");
}

//${BaseAOs::Terminal::LoadCustomEvt} ........................................
void Terminal::LoadCustomEvt(const CustomEvt* customEvent) {
    consoleDisplay("Empty Custom Event command\r\n");
}

//${BaseAOs::Terminal::PublishShowStateEvent} ................................
void Terminal::PublishShowStateEvent() {
    // Cause system to broadcast state
    CustomEvt* pe = Q_NEW(CustomEvt, SHOW_STATE_SIG);
    QP::QActive::PUBLISH(pe, this);
}

//${BaseAOs::Terminal::SM} ...................................................
Q_STATE_DEF(Terminal, initial) {
    //${BaseAOs::Terminal::SM::initial}
    m_maxInputSize = sizeof(m_input)/sizeof(m_input[0]);
    subscribe(CUSTOM_SIG);
    return tran(&running);
}

//${BaseAOs::Terminal::SM::running} ..........................................
Q_STATE_DEF(Terminal, running) {
    QP::QState status_;
    switch (e->sig) {
        //${BaseAOs::Terminal::SM::running::initial}
        case Q_INIT_SIG: {
            consoleDisplay("Terminal running\r\n");
            m_maxInputSize = sizeof(m_input)/sizeof(m_input[0]);
            status_ = tran(&start);
            break;
        }
        //${BaseAOs::Terminal::SM::running::CUSTOM}
        case CUSTOM_SIG: {
            const CustomEvt* pe = static_cast<const CustomEvt*>(e);
            LoadCustomEvt(pe);
            status_ = Q_RET_HANDLED;
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}

//${BaseAOs::Terminal::SM::running::receiveUserReply} ........................
Q_STATE_DEF(Terminal, receiveUserReply) {
    QP::QState status_;
    switch (e->sig) {
        //${BaseAOs::Terminal::SM::running::receiveUserReply::initial}
        case Q_INIT_SIG: {
            //consoleDisplay("Terminal ::Receiving USART\r\n");
            memset(m_input, 0, m_maxInputSize);
            m_gotReply = false;
            m_gotChar = true;
            m_replySize = 0;

            consoleReadAsyncInit();
            status_ = tran(&receivingNextChar);
            break;
        }
        default: {
            status_ = super(&running);
            break;
        }
    }
    return status_;
}

//${BaseAOs::Terminal::SM::running::receiveUserReply::receivingNextChar} .....
Q_STATE_DEF(Terminal, receivingNextChar) {
    QP::QState status_;
    switch (e->sig) {
        //${BaseAOs::Terminal::SM::running::receiveUserReply::receivingNextChar}
        case Q_ENTRY_SIG: {
            if ( m_gotChar )
            {
                m_gotChar = false;
                consoleReadByteAsync();
            }

            m_timeEvt.armX(50, 0U);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${BaseAOs::Terminal::SM::running::receiveUserReply::receivingNextChar}
        case Q_EXIT_SIG: {
            m_timeEvt.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${BaseAOs::Terminal::SM::running::receiveUserReply::receivingNextCha~::TIMEOUT}
        case TIMEOUT_SIG: {
            m_gotChar = (consoleInputReady()) ? true : false;

            if ( m_gotChar )
            {
                m_gotReply = (consoleInputDone()) ? true : false;
            }
            //${BaseAOs::Terminal::SM::running::receiveUserReply::receivingNextCha~::TIMEOUT::[NotDone]}
            if (!m_gotReply) {
                status_ = tran(&receivingNextChar);
            }
            //${BaseAOs::Terminal::SM::running::receiveUserReply::receivingNextCha~::TIMEOUT::[GotReply]}
            else if (m_gotReply) {
                m_replySize = consoleReadString(m_input, m_maxInputSize);
                //consoleDisplay("\r\n");
                //consoleDisplay(m_input);
                consoleDisplayArgs("\r\n%s;", m_input);
                this->DispatchCommand(m_input[0]);
                status_ = tran(&sendUserPrompt);
            }
            else {
                status_ = Q_RET_UNHANDLED;
            }
            break;
        }
        default: {
            status_ = super(&receiveUserReply);
            break;
        }
    }
    return status_;
}

//${BaseAOs::Terminal::SM::running::start} ...................................
Q_STATE_DEF(Terminal, start) {
    QP::QState status_;
    switch (e->sig) {
        //${BaseAOs::Terminal::SM::running::start}
        case Q_ENTRY_SIG: {
            //consoleDisplay("Terminal ::Idle\r\n");
            m_timeEvt.armX(1000, 0U);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${BaseAOs::Terminal::SM::running::start}
        case Q_EXIT_SIG: {
            m_timeEvt.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${BaseAOs::Terminal::SM::running::start::TIMEOUT}
        case TIMEOUT_SIG: {
            PublishShowStateEvent();
            status_ = tran(&sendUserPrompt);
            break;
        }
        default: {
            status_ = super(&running);
            break;
        }
    }
    return status_;
}

//${BaseAOs::Terminal::SM::running::sendUserPrompt} ..........................
Q_STATE_DEF(Terminal, sendUserPrompt) {
    QP::QState status_;
    switch (e->sig) {
        //${BaseAOs::Terminal::SM::running::sendUserPrompt}
        case Q_ENTRY_SIG: {
            m_timeEvt.armX(500, 0U);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${BaseAOs::Terminal::SM::running::sendUserPrompt}
        case Q_EXIT_SIG: {
            m_timeEvt.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${BaseAOs::Terminal::SM::running::sendUserPrompt::TIMEOUT}
        case TIMEOUT_SIG: {
            consoleDisplay("Enter command;\r\n");
            status_ = tran(&receiveUserReply);
            break;
        }
        default: {
            status_ = super(&running);
            break;
        }
    }
    return status_;
}

} // namespace APP
//$enddef${BaseAOs::Terminal} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
